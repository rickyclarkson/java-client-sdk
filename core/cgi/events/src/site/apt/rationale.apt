 ---------
 Rationale
 ---------

Rationale

* Builders

  In designing the EventsCGI API, we need to allow the user to supply the values of around 10 parameters.  Some of those parameters conflict with each other, and all of them are optional.  Let's look at some options for an API accepting these 10 parameters, aiming to get the best balance between safety and readability, in both the use and the implementation.

 [[1]] A long parameter list.

---

  foo(bar, baz, spam, eggs);

---

  More the problem than a solution, the flaws in a long parameter list are clear.  Users forget the order of the parameters (though in Eclipse Ctrl-shift-Space lists them in tooltips), which the compiler catches if you help it (see Military Typing later in this document).

  Also it's unclear what to do about optional parameters - use nulls, have a large number of overloads, have the user insert all the defaults that they're not interested in or something else.

  And as some of the parameters conflict with each other, there would need to be some overloads of the method.

 [[2]] An anonymous subclass of the type we want that directly accesses variables to set them in its initialisation block.

---

EventsCGI cgi = new EventsCGI()
{
    {
        time = 300;
        text = "hello";
        sysMask = 127; //oops, not allowed both text and sysMask
        time = 400; //oops, can set the same value twice
    }
};

---

  A couple of flaws with this are shown above in comments, though probably at least one IDE can flag up the duplicate write to 'time' as a problem.  The mutually exclusive parameters, text and sysMask, can be checked after the constructor has run.  Also, if an exception is thrown when any checks are performed, the stack trace won't appear to come from the line "sysMask = 127;", which might be a problem.

 [[3]] An anonymous subclass of the type we really want, which uses accessors to set the values, in its initialisation block.

---

EventsCGI cgi = new EventsCGI()
{
    {
        time.set(300);
        text.set("hello");
        sysMask.set(127); //now a runtime check could disallow this.
        time.set(400); //and this.
    }
};

---

  Sadly, despite being a litt   le safer, this is a little harder to read than the preceding version.

 [[4]] A mutable builder.

---

EventsCGI cgi = new EventsCGI.Builder().time( 100 ).time( 200 )
    .time( 300 ).build();
//the above line will throw an exception on the second call to
//time.

---

  So it can have safety, because you can check any values at any point in the construction.  It's not quite as reusable as it could be because it is mutable.  For example, you could not store a partly-completed builder and later complete it with two other options separately without having them potentially interfere with each other. 
 
 [[5]] The final option is an immutable builder with as much static type-checking as possible - in the simplest cases this isn't bad, but the amount of implementation code needed explodes when optional parameters and mutually exclusive parameters are involved.

  We opted to go with the 4th option, which is the option Joshua Bloch {{{http://www.newt.com/java/effective-java-reloaded.pdf}documented (PDF)}}.

* Military Typing

  For some parameters to the builders in the Event Database API, the exact ranges of values that should be accepted are different to those provided in Java's primitive types.  For example, the 'time' parameter has a documented range of 0 to 2^31-1, which luckily is the same as the non-negative part of Java's int type (a signed 32-bit two's complement integer).  You could make public APIs include some type UInt31, or Unsigned31, etc.  Here's how using that would look:

---

new EventsCGI.Builder().time(new Unsigned31(some value))
new EventsCGI.Builder().time(unsigned31(some value)) //using a static import
new EventsCGI.Builder().time(Unsigned31.valueOf(some value))

---

  The advantage that Unsigned31 has over using an int in a public API is that it documents that not all int values are acceptable, and prevents the checking of that value from being repeated everywhere that the value is read in from the API user.

  By providing restrictive types before the main API methods are even invoked, we don't have to worry about remembering to throw IllegalArgumentExceptions from each API method (and remembering to test that), but only in the constructor for Unsigned31.

  We've used the term Military Typing for this after the (quite opinionated) blog post {{http://syntaxfree.wordpress.com/2006/12/24/static-vs-dynamic-typing-do-what-thou-wilt/}} - worth a read for some background on the matter.

  After discussion, we decided to keep the API as small as possible, so we are now using Java's built-in types in the API, rather than providing bounded wrapper classes.  This means that we lose some of the self-documenting nature of the API, have to repeat the checks that Unsigned31 does (or use Unsigned31 internally) and have to consider what to do if the user gives us an int outside the range we want (previously this would have been handled by the Unsigned31 constructor), but the appearance of the user's code is better.

* Implementation of Builders

** Introduction

  When writing the EventsCGI, VariableCGI, VPartsCGI and DecoderCGI builders and parsers, the API style that we agreed upon seemed to encourage logic to be spread out and repeated.  As a brief recap, we were trying to avoid a single factory method or constructor with a long parameter list, because it's too easy for a client to get wrong, and calls to it aren't particularly readable.  Here's an example of that:

----

Person person = new Person( "John", "Jackson", 1979, 11, 10,
    "AC2193" );

----

  We wanted something more like:

----

Person person = new Person.Builder().forename( " John" )
    .surname( "Jackson" ).yearOfBirth( 1979 )
    .monthOfBirth( 11 ).dateOfBirth( 10 )
    .nationalInsuranceNumber( "AC2193" ).build();

----

  To keep the code short, we'll use a simpler class as an example, a Person consisting of name and age.

----

public class Person
{
    private final String name;
    private final int age;

    private Person( Builder builder )
    {
        this.builder = builder;
    }

    public static class Builder
    {
        private String name;
        private int age;

        public Builder name( String name )
        {
            this.name = name;
            return this;
        }

        public Builder age( int age )
        {
            this.age = age;
            return this;
        }

        public Person build()
        {
            return new Person( this );
        }
    }

    public String getName()
    {
        return name;
    }

    public int age()
    {
        return age;
    }
}

----

** MaxOnce

  Even for 2 parameters, this is quite a lot of code, though thus far there isn't really any logic to be duplicated.  Now let's look at a really simple constraint, that values cannot be set twice.

  The most obvious way of trying this would be to have a boolean alongside each field in the builder, e.g.:

----

private String name;
private boolean nameAlreadySet;

private int age;
private boolean ageAlreadySet;

----

  And then in the name( String ) and age( int ) methods in the Builder you would check the value of that boolean, and throw an IllegalStateException if the boolean had already been set.  This is clearly a repetition, which can lead to copy-and-paste errors or just make things hard to change.

  In object-orientated programming the usual way of handling this would be to package the field with its boolean in an object, which we decided to call MaxOnce.  Though it doesn't exist in the current version of the code, we had it in an early version and it's relevant in understanding the reasons for the current design.

----

class MaxOnce<T>
{
    private T value;
    private boolean alreadySet;
    private final String name;

    public MaxOnce( T defaultValue, String name )
    {
        value = defaultValue;
        this.name = name;
    }

    public void set( T newValue )
    {
        if ( alreadySet )
        {
            throw new IllegalStateException( "Cannot set " + name +
                " to " + newValue + "; it already has the value " +
                value );
        }

        value = newValue;
        alreadySet = true;
    }

    public T get()
    {
        return value;
    }
}

----

  So then the fields section in the Builder would look like this:

----

private final MaxOnce<String> name =
    new MaxOnce<String>( null, "name" );

private final MaxOnce<Integer> age =
    new MaxOnce<Integer>( 0, "age" );

----

  This is handy because it also moves the logic from the methods in the Builder class to one place, the MaxOnce class, solving the general goal of keeping logic unrepeated.

** BoundedInt and ParameterDescription

  It's easy to guess that the age of a Person should be restricted to values greater than 0 (which in turn makes the default value of 0 a bit useless, but we'll get around to that).  It's easy enough to add in such a constraint in the Builder's methods:

----

public Builder age( int age )
{
    if ( age <= 0 )
    {
        throw new IllegalArgumentException( age + " is not a " +
            "valid value for the age parameter" );
    }

    this.age = age;

    return this;
}

----

  If the above was followed for all the CGI queries, we would find it repeated in a number of places.  There is a slight urge to add bounds checking to MaxOnce, but if that was done then MaxOnce would no longer be a good name for it!

  One idea that fell by the wayside was a BoundedInt type, which had a 'set' method that would check bounds.  So you could have, in the Builder:

----

private final BoundedInt age = new BoundedInt( 0, 0,
    Integer.MAX_VALUE, "age" );

----

  This would work but it wouldn't compose well with MaxOnce.  If you wrote:

----

private final MaxOnce<BoundedInt> age = new MaxOnce<BoundedInt>(
    new BoundedInt( 0, 0, Integer.MAX_VALUE, "age"), "age" );

----

  then you would probably start to get annoyed!  Plus, it becomes difficult to make sure you call the set methods of both MaxOnce and BoundedInt properly.  It would help if MaxOnce and BoundedInt were more like filters that data gets passed through (or not, if the data is invalid).  Enter the ParameterDescription class, or rather, the first iteration of it:

----

private final ParameterDescription<String> name = maxOnce( "name", null );

private final ParameterDescription<Integer> age = bound( maxOnce( "age", 0 ),
    0, Integer.MAX_VALUE );

----

  Notice how bound and maxOnce are chained together in the age parameter.  It's easy to see how you might write other filters.  Here's a largely useless example:

----

ParameterDescription<Integer> number = 
    not ( 5,
    bound (
        maxOnce ( 0, "a number from one to ten, but not five" ),
        0, 10 ) );

----

** Option

  As hinted at earlier, it seems a shame to have to provide default values for parameters that should always be set.  For the name parameter, the default value is null, and for the age parameter, it is 0, but we never want those defaults to escape - they're only there because we have to store something.

  It's likely that there are a few good ways of solving this, but the way chosen here turns out to be general enough to work for yet another use case that was unknown at the time ('sparse arrays', documented in the DecoderCGI module).

  Sometimes in APIs you might be faced with a choice between returning some error code, null or throwing an exception.  There is another option that you'll see dotted around in some APIs - to return a list instead, where that list is empty in the error case.  This is convenient for the caller, who doesn't have to remember to check for null, or catch some exception, but can just iterate over the returned list.

  In many such cases, there are only zero or one elements, which seems an abuse of lists, because it's not quite as self-documenting as it could be.  ListWith1Or0Elements is a terrible name, but hopefully having set the scene with that name, anything else will seem better!  A better name for it is Option.  Here's a small example:

----

Option<String> myName;

if ( Math.random() < 0.5 )
{
    myName = some( "Bob" );
}
else
{
    myName = none();
}

----

  To translate this to its List equivalent, using the utility methods in java.util.Collections:

----

List<String> myName;

if ( Math.random() < 0.5 )
{
    myName = singletonList( "Bob" );
}
else
{
    myName = emptyList();
}

----

  Compare this to the first version.  If you know what Option means (which you now do!) then you can see from the first line that there is only zero or one value, rather than having to follow the code flow to work that out.

  Option could trivially implement the Iterable interface, so that you could use it in a foreach loop, but as Option is not exposed in our APIs, and we don't yet have a reason to use it in a foreach loop, it doesn't.

  So, back to Parameter, for a name parameter that has no default, it might be handy to store the value as an Option.  But as some parameters do have real defaults, it wouldn't make sense to make all Parameters store their value as Options.  Plus, Option would be insufficient for the sparse arrays as documented in the DecoderCGI's rationalelater.  So Parameter needs two type parameters, not one.  The first describes the type going in, the second describes the type coming out (being stored), quite like a filter.

----

private final Parameter<String, Option<String>> name =
    maxOnce( "name" );

private final Parameter<Integer, Option<Integer>> age =
    bound( maxOnce( "age" ), 0, Integer.MAX_VALUE );

----

  Note that bound and maxOnce work together for the age parameter, as two filters.

  One more factor is needed to explain the differences between what has been described here thus far and the actual code; immutability.  Mutable state is a problem in software in general - a mutable object needs managing.  If Sun exposed the char[] inside java.lang.String I could make System.out.println( "Hello World"); actually print "Well, hello".  If you expose an internal List, array or StringBuilder that you depend on then you're likely to cause problems for yourself.  There are solutions, such as defensively cloning objects, but all these problems go away if you make objects immutable where possible.

  In the design as documented so far, each Parameter is mutable, as it holds a value that can change.  But really when we see the line where the Parameter is declared:

----

private final Parameter<String, Option<String>> name =
    maxOnce( "name" );

----

  we can see that it is more a declaration of the parameter than it is an actual value.  We can make this immutable by moving the value elsewhere.  Roughly, we can move it to a Map\<Parameter, Object\> but with slightly better types.  The types of this map are a little awkward to get right, as {{{http://code.google.com/p/google-guice/source/browse/trunk/src/com/google/inject/InjectorImpl.java?r=255}Bob Lee found while implementing Guice}} (search for 'unchecked'), so it's wise to wrap this map up, preventing incorrectly-typed access.  The wrapper in this project is called GenericBuilder.

  By moving the values of all the parameters to GenericBuilder, we can then make the whole thing immutable by making changes to the GenericBuilder not actually change the instance but return a new instance.  Unfortunately, the implementations of Map that come with Java are certainly not optimised for this copy-on-write behaviour, but there are some fast immutable hashtable implementations out there ready for us to use if there turns out to be a performance problem.  Probably a better optimisation would be to stop using TreeMap anyway, as it isn't especially fast or compact for small datasets.

  So with GenericBuilder involved, we don't even need the parameters to be instance fields any more.  Here's the original Person class with this implementation:

----

public class Person
{
    private final GenericBuilder finalValues;

    private static final Parameter<String, Option<String>> nameParam =
        param( "name", "The name of the person",
        Conversion.<String>identity() );

    private static final Parameter<Integer, Option<Integer>> ageParam
        = notNegative( param( "age", "The age of the person",
        Conversion.stringToInt );

    private Person( GenericBuilder finalValues )
    {
        this.finalValues = finalValues;
    }

    public static final class Builder
    {
        private GenericBuilder realBuilder = new GenericBuilder();

        public Builder name( String name )
        {
            realBuilder = realBuilder.with( nameParam, name );
            return this;
        }

        public Builder age( int age )
        {
            realBuilder = realBuilder.with( ageParam, age );
            return this;
        }

        public Person build()
        {
            if ( realBuilder.isDefault( nameParam ) ||
                realBuilder.isDefault( ageParam ) )
            {
                throw new IllegalStateException( "Not all the " +
                    "parameters have been given a value" );
            }

            return new Person( realBuilder );
        }
    }

    public String getName()
    {
        return finalValues.get( nameParam );
    }

    public int getAge()
    {
        return finalValues.get( ageParam );
    }
}

----

  Something that has changed here is the maxOnce method has been renamed to param, which is only because there are no parameters that are allowed to be set twice so far, so the name maxOnce seemed redundant.  Person also has no other private fields than the finalValues field, which is quite safe because the values held by finalValues cannot change.

  Also, because a large part of the project is about parsing and building URLs, you'll notice that the parameters here include a Conversion\<String, T\>, which is just an object that describes how to go from a String to the type expected by the parameter.  This helps in keeping parsing and building from and to URLs minimal (GenericBuilder has a couple of convenience methods for this).