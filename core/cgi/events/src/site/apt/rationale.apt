 ---------
 Rationale
 ---------

Rationale

* Builders

  In designing the EventsCGI API, we need to allow the user to supply the values of around 10 parameters.  Some of those parameters conflict with each other, and all of them are optional.  Let's look at some options for an API accepting these 10 parameters, aiming to get the best balance between safety and readability, in both the use and the implementation.

 [[1]] A long parameter list.

---

  foo(bar, baz, spam, eggs);

---

  More the problem than a solution, the flaws in a long parameter list are clear.  Users forget the order of the parameters (though in Eclipse Ctrl-shift-Space lists them in tooltips), which the compiler catches except in the case of equally-typed parameters (see Military Typing later in this document).

  Also it's unclear what to do about optional parameters - use nulls, have a large number of overloads, have the user insert all the defaults that they're not interested in (this can be helped by static constants) or something else.

  And as some of the parameters conflict with each other, there would need to be a number of overloads of the method.

 [[2]] An anonymous subclass of the type we want that directly accesses variables to set them in its initialisation block.

---

EventsCGI cgi = new EventsCGI()
{{
 time = 300;
 text = "hello";
 sysMask = 127; //oops, not allowed text and sysMask
 time = 400; //oops, can set the same value twice
}};

---

  A couple of flaws with this are shown above in comments, though probably at least one IDE can flag up the duplicate write to 'time' as a problem.  The text and sysMask together can be checked after the constructor has run, though it's worth pointing out that you can't check this in the superclass' constructor.  Also, if an exception is thrown when the check is performed, the stack trace won't appear to come from the line "sysMask = 127;", which might be a problem.

  Code formatters will often format the above code in a much less readable way because of the double braces.  Also, the style of code is quite alien to most developers, and it's quite arguable that you should avoid doing much in constructors, though in this case it's quite safe.

 [[3]] An anonymous subclass of the type we want that uses accessors through accessors to set them in its initalisation block.

---

Events events = new Events()
{{
 time.set(300);
 text.set("hello");
 sysMask.set(127); //now a runtime check could disallow this.
 time.set(400); //and this.
}};

---

  Sadly, despite being a little safer, this is a little harder to read than the preceding version.

 [[4]] A mutable builder.

---

EventsCGI cgi = new Events.Builder().time( 100 ).time( 200 ).time( 300 ).build();
//the above line will throw an exception on the second call to setTime.

---

  So it can have safety, because you can check any values at any point in the implementation.  It's not quite as reusable as it could be because it's mutable.  For example, you could not store a partly-completed builder and later complete it with two other options separately without having them potentially interfere with each other. 
 
 [[5]] The final option is an immutable builder with as much static type-checking as possible - in the simplest cases these are not bad, but the amount of implementation code needed explodes when optional parameters and mutually exclusive parameters are involved.

---

  We opted to go with the 4th option, which is the option Joshua Bloch documented.

* Military Typing

  For some parameters to the builders in the Event Database API, the exact ranges of values that should be accepted are different to those provided in Java's primitive types.  For example, the 'time' parameter has a documented range of 0 to 2^31-1, which luckily is the same as the non-negative part of Java's int (a signed 32-bit two's complement integer).  I (Ricky) came up with the type UInt31 for this, so the user would write one of the following:

---

new EventsCGI.Builder().time(new UInt31(some value))
new EventsCGI.Builder().time(uint31(some value)) //using a static import
new EventsCGI.Builder().time(UInt31.valueOf(some value))

---

  Perhaps Unsigned31 would be a better name to expose to the user, though the name doesn't fundamentally change how the API is used.

  The advantage that UInt31 has over providing an int in public API is that it documents immediately that not all int values are acceptable, and prevents the checking of that value from being repeated everywhere that the value is read in from the API user.

  By providing restrictive types before the main API methods are even invoked, we don't have to worry about throwing IllegalArgumentExceptions from each API method, but only in the constructor for UInt31.

  We've called this Military Typing after the (quite opinionated) blog post {{http://syntaxfree.wordpress.com/2006/12/24/static-vs-dynamic-typing-do-what-thou-wilt/}} - worth a read for some background on the matter.

  In other places in the API there are more arbitrary permitted number ranges, e.g., one field (offset in EventsCGIResult) has a range of -90,000 to +90,000 inclusive - it would be hard to appropriately name that by its range - IntFromMinus90000ToPlus90000 would be awful to work with.  Another way would be to create a named type for that parameter, e.g., Offset (which might extend some BoundInt type for all its implementation).  This would rule out the class of broken code where invalid values are passed to our APIs, but would make the caller have to do more work: new EventsCGI.Builder().offset(new Offset(30)) instead of new EventsCGI.Builder().offset(30).  Also, it introduces one possible invalid value, null.

  Craig decided to keep the API as small as possible, so we are now using Java's built-in types in the API, rather than providing bounded wrapper classes.  This means that we lose some of the self-documenting nature of the API, have to repeat the checks that UInt31 does (or use UInt31 internally) and have to consider what to do if the user gives us an int outside the range we want (previously this would have been handled by the UInt31 constructor), but the appearance of the user's code is better. 