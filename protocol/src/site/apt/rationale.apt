Rationale

* CheckParameters

 Every public method other than equals methods disallows null parameters to methods, and rather than write:

 if (x == null || y == null || z == null) throw new NullPointerException(); in each method, it's a little more flexible to write:

 CheckParameters.areNotNull(x, y, z);

 The NullPointerException that notNull can throw contains the index of the null parameter, so if y was null above, the exception message would mention the 2nd parameter.

* DecoderCGI

 DecoderCGI is the only module so far that does not use the Builder pattern.  It is written this way to avoid nested Builder use, or fragile Builders (as in RIFE).  In general, if building X requires a Y, and building Y requires a Z, the code using Builders would look like: new X.Builder().y(new Y.Builder().z(new Z()).build()).build(), and that's for the simplest possible example!  With the way DecoderCGI is written you would instead write: new X().y(new Y().z(new Z())).  This only works well for DecoderCGI because a DecoderCGI containing no values is perfectly valid.  An alternative to this nested building would be to copy RIFE's idea of having 'contextual' method calls: startX().startY().z(new Z()).endY().endX(), where normal code is emulated through method calls.  I don't think this is a good idea.

 DecoderCGI is currently immutable, so the objects created from it can be reused by adding more parameters to them.  This is quite different to the Builder approach, where each Builder is 'one-shot'; the caller can not add more parameters after calling build().  This is a positive for DecoderCGI in terms of code quality, but as we expect the callers to be novice programmers, they might be more used to handling mutable objects.  Java forums endlessly have questions about String's replaceAll method, because String's immutability surprises novices.  String in Java cannot be made mutable to remove that surprise, as Strings are shared across threads and are important for security.  DecoderCGI doesn't have similar constraints, but it's difficult to imagine all the possible uses of a class.  It might be appropriate to make it mutable.

* DisplayPicCGI and ReplayPicCGI

 DisplayPicCGI and ReplayPicCGI provide a type-safe way of constructing display_pic.cgi and replay_pic.cgi requests respectively.  They use ParameterMap and ParameterDescription heavily, and are identical to EventsCGI other than the parameters that they support.  Typical use will be either producing a URL from an object or parsing a URL to form an object.

* Function

 A Function represents a mapping from one type to another.

 They are useful in that because they are objects and not just methods, they can be passed around as values, and chained to produce new Functions that are no more complex to use than the unchained versions.

 The Function class contains a number of useful conversions between Java's built-in types.

* Format

 Most of the CGI requests need to specify what format the results return in.  Rather than repeat the Format enum in each module that uses it, we keep it in core/cgi/common.

* IPAddress

 This wraps an IPv4 address, providing mechanisms for going between a String and an IPAddress.  This could have just been an int, but it's worth wrapping as an IPAddress to avoid mistakes - especially as Java's ints are signed.  For example, one could not write the IP address 192.168.0.1 as 192 \<\< 24 + 168 \<\< 16 + 0 \<\< 8 + 1, because 192 \<\< 24 overflows an int's boundary, causing the addition to be incorrect.

* Num

 Num is used to allow generic methods that need arithmetic operations to work without copying and pasting code.  {{{http://rickyclarkson.blogspot.com/2009/01/typeclass-pattern.html}This blog post explains why it is useful}}, though at the time of this writing there is only Num.integer().

* Option

 Option is a container that can contain either one or zero elements.  It is used to allow a ParameterDescription to work for compulsory parameters, by allowing the ParameterMap to distinguish between an unset parameter and a parameter that has a value, without resorting to sentinel values, and it's used throughout the API to represent failure, e.g., Conversion.stringToLong gives an empty option for "foo", and an option containing the Long 5 for "5".

* Pair

 Pair is useful for passing two values where an API only expects one.  It's used by ParameterDescription so that sparse array parameters don't have to be a special case.  ParameterDescription's type parameters are T and R, where T means the input type.  For sparse arrays, the input type needs to have two values; the index into the sparse array and the value to place there, which doesn't fit in ParameterDescription's type parameters.  A Pair is one value, so that works well.

* ParameterDescription

 A ParameterDescription is a specification of a parameter for a Builder.  It doesn't contain any mutable data, it only works as a specification, leaving ParameterMap to store the data.

 It has an input type and an output type, and knows how to convert the former to the latter, so that it can store values flexibly.  For example, an ordinary parameter with no default has type ParameterDescription<T, Option<T>>, so that the stored value can be an empty Option until a value has been passed in.  This avoids error-prone sentinel values.

* Sparse Array ParameterDescriptions.

 The decoder.frm and decoder.var CGI requests are capable of updating parts of a number of system variables.  So they might update elements 3, 4 and 6 of the layouts array.  The array on the server is a normal array, but the elements being updated form a sparse array, which is something like a Map\<Integer, Layout\> in Java.  The DecoderCGI's layouts parameter can take a Pair\<Integer, Layout\> and add it to a TreeMap\<Integer, Layout\>.  TreeMap is chosen because it is guaranteed to be ordered by its keys.

* ParameterMap

 A ParameterMap stores the values associated with ParameterDescriptions, and includes a Validator, to make writing Builders that have constraints easy.  Storing a new value produces a new ParameterMap rather than changing the original ParameterMap, which helps in flexibility for the caller.

* Reduction

 As in Google's Map/Reduce framework, a Reduction is a general transformation from 2 values to 1 value, that can be used across many values in turn to 'reduce' n values to 1.  For example, a Reduction that takes two Integers and returns their sum can be used to sum a collection of Integers.  In this codebase, it is used as a general way of allowing a Parameter to take in n values, one by one, and have some mechanism for deciding what value to store after each is received.  This is important for sparse array Parameters, which take in values of type Pair<Integer, T> and store them in a TreeMap.  Doing without it would mean writing sparse array parameters as a separate implementation, rather than benefitting from the single flexible implementation.

* Strings

 Strings contains utility methods and Functions that help in parsing and generating URL parameters and CSV.

* StringConversion

 This is roughly a Pair<Function<String, Option<T>>, Function<T, Option<String>>> - i.e., it provides partial conversions between a Parameter's input type and Strings, which is used in parsing and building URL parameters and CSV.  The two Functions are joined because otherwise, ParameterDescription's methods are hard to read and repetitive.

* URLEncoder

 This wraps java.net.URLEncoder to provide an interface that doesn't involve checked exceptions.  It also includes a Function that URL-encodes Strings, which is composed with other Functions by various other modules.