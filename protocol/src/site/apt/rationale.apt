 ----
 Rationale
 ----

* CheckParameters

 Every public method other than equals methods disallows null parameters to methods, and rather than write:

 if (x == null || y == null || z == null) throw new NullPointerException(); in each method, it's a little more flexible to write:

 CheckParameters.areNotNull(x, y, z);

 The NullPointerException that notNull can throw contains the index of the null parameter, so if y was null above, the exception message would mention the 2nd parameter.

* Function

 A Function represents a mapping from one type to another.

 They are useful in that because they are objects and not just methods, they can be passed around as values, and chained to produce new Functions that are no more complex to use than the unchained versions.

 The Function class contains a number of useful conversions between Java's built-in types.

* Format

 Most of the CGI requests need to specify what format the results return in.  Rather than repeat the Format enum in each module that uses it, we keep it in core/cgi/common.

* Option

 Option is a container that can contain either one or zero elements.  It is used to allow a ParameterDescription to work for compulsory parameters, by allowing the ParameterMap to distinguish between an unset parameter and a parameter that has a value, without resorting to sentinel values, and it's used throughout the API to represent failure, e.g., Conversion.stringToLong gives an empty option for "foo", and an option containing the Long 5 for "5".

* Pair

 Pair is useful for passing two values where an API only expects one.  It's used by ParameterDescription so that sparse array parameters don't have to be a special case.  ParameterDescription's type parameters are T and R, where T means the input type.  For sparse arrays, the input type needs to have two values; the index into the sparse array and the value to place there, which doesn't fit in ParameterDescription's type parameters.  A Pair is one value, so that works well.

* ParameterDescription

 A ParameterDescription is a specification of a parameter for a Builder.  It doesn't contain any mutable data, it only works as a specification, leaving ParameterMap to store the data.

 It has an input type and an output type, and knows how to convert the former to the latter, so that it can store values flexibly.  For example, an ordinary parameter with no default has type ParameterDescription<T, Option<T>>, so that the stored value can be an empty Option until a value has been passed in.  This avoids error-prone sentinel values.

** Sparse Array ParameterDescriptions.

 The decoder.frm and decoder.var CGI requests are capable of updating parts of a number of system variables.  So they might update elements 3, 4 and 6 of the layouts array.  The array on the server is a normal array, but the elements being updated form a sparse array, which is something like a Map\<Integer, Layout\> in Java.  The DecoderCGI's layouts parameter can take a Pair\<Integer, Layout\> and add it to a TreeMap\<Integer, Layout\>.  TreeMap is chosen because it is guaranteed to be ordered by its keys.

* ParameterMap

 A ParameterMap stores the values associated with ParameterDescriptions, and includes a Validator, to make writing Builders that have constraints easy.  Storing a new value produces a new ParameterMap rather than changing the original ParameterMap, which helps in flexibility for the caller.

* Reduction

 As in Google's Map/Reduce framework, a Reduction is a general transformation from 2 values to 1 value, that can be used across many values in turn to 'reduce' n values to 1.  For example, a Reduction that takes two Integers and returns their sum can be used to sum a collection of Integers.  In this codebase, it is used as a general way of allowing a Parameter to take in n values, one by one, and have some mechanism for deciding what value to store after each is received.  This is important for sparse array Parameters, which take in values of type Pair<Integer, T> and store them in a TreeMap.  Doing without it would mean writing sparse array parameters as a separate implementation, rather than benefitting from the single flexible implementation.

* Strings

 Strings contains utility methods and Functions that help in parsing and generating URL parameters and CSV.

* StringConversion

 This is roughly a Pair<Function<String, Option<T>>, Function<T, Option<String>>> - i.e., it provides partial conversions between a Parameter's input type and Strings, which is used in parsing and building URL parameters and CSV.  The two Functions are joined because otherwise, ParameterDescription's methods are hard to read and repetitive.

* URLEncoder

 This wraps java.net.URLEncoder to provide an interface that doesn't involve checked exceptions.  It also includes a Function that URL-encodes Strings, which is composed with other Functions by various other modules.

* Builders

  In designing the EventsCGI API, we need to allow the user to supply the values of around 10 parameters.  Some of those parameters conflict with each other, and all of them are optional.  Let's look at some options for an API accepting these 10 parameters, aiming to get the best balance between safety and readability, in both the use and the implementation.

 [[1]] A long parameter list.

---

  foo(bar, baz, spam, eggs);

---

  More the problem than a solution, the flaws in a long parameter list are clear.  Users forget the order of the parameters (though in Eclipse Ctrl-shift-Space lists them in tooltips), which the compiler catches if you help it (see Military Typing later in this document).

  Also it's unclear what to do about optional parameters - use nulls, have a large number of overloads, have the user insert all the defaults that they're not interested in or something else.

  And as some of the parameters conflict with each other, there would need to be some overloads of the method.

 [[2]] An anonymous subclass of the type we want that directly accesses variables to set them in its initialisation block.

---

EventsCGI cgi = new EventsCGI()
{
    {
        time = 300;
        text = "hello";
        sysMask = 127; //oops, not allowed both text and sysMask
        time = 400; //oops, can set the same value twice
    }
};

---

  A couple of flaws with this are shown above in comments, though probably at least one IDE can flag up the duplicate write to 'time' as a problem.  The mutually exclusive parameters, text and sysMask, can be checked after the constructor has run.  Also, if an exception is thrown when any checks are performed, the stack trace won't appear to come from the line "sysMask = 127;", which might be a problem.

 [[3]] An anonymous subclass of the type we really want, which uses accessors to set the values, in its initialisation block.

---

EventsCGI cgi = new EventsCGI()
{
    {
        time.set(300);
        text.set("hello");
        sysMask.set(127); //now a runtime check could disallow this.
        time.set(400); //and this.
    }
};

---

  Sadly, despite being a litt   le safer, this is a little harder to read than the preceding version.

 [[4]] A mutable builder.

---

EventsCGI cgi = new EventsCGI.Builder().time( 100 ).time( 200 )
    .time( 300 ).build();
//the above line will throw an exception on the second call to
//time.

---

  So it can have safety, because you can check any values at any point in the construction.  It's not quite as reusable as it could be because it is mutable.  For example, you could not store a partly-completed builder and later complete it with two other options separately without having them potentially interfere with each other. 
 
 [[5]] The final option is an immutable builder with as much static type-checking as possible - in the simplest cases this isn't bad, but the amount of implementation code needed explodes when optional parameters and mutually exclusive parameters are involved.

  We opted to go with the 4th option, which is the option Joshua Bloch {{{http://www.newt.com/java/effective-java-reloaded.pdf}documented (PDF)}}.

* Military Typing

  For some parameters to the builders in the Event Database API, the exact ranges of values that should be accepted are different to those provided in Java's primitive types.  For example, the 'time' parameter has a documented range of 0 to 2^31-1, which luckily is the same as the non-negative part of Java's int type (a signed 32-bit two's complement integer).  You could make public APIs include some type UInt31, or Unsigned31, etc.  Here's how using that would look:

---

new EventsCGI.Builder().time(new Unsigned31(some value))
new EventsCGI.Builder().time(unsigned31(some value)) //using a static import
new EventsCGI.Builder().time(Unsigned31.valueOf(some value))

---

  The advantage that Unsigned31 has over using an int in a public API is that it documents that not all int values are acceptable, and prevents the checking of that value from being repeated everywhere that the value is read in from the API user.

  By providing restrictive types before the main API methods are even invoked, we don't have to worry about remembering to throw IllegalArgumentExceptions from each API method (and remembering to test that), but only in the constructor for Unsigned31.

  We've used the term Military Typing for this after the (quite opinionated) blog post {{http://syntaxfree.wordpress.com/2006/12/24/static-vs-dynamic-typing-do-what-thou-wilt/}} - worth a read for some background on the matter.

  After discussion, we decided to keep the API as small as possible, so we are now using Java's built-in types in the API, rather than providing bounded wrapper classes.  This means that we lose some of the self-documenting nature of the API, have to repeat the checks that Unsigned31 does (or use Unsigned31 internally) and have to consider what to do if the user gives us an int outside the range we want (previously this would have been handled by the Unsigned31 constructor), but the appearance of the user's code is better.

* Implementation of Builders

** Introduction

  When writing the EventsCGI, VariableCGI, VPartsCGI and DecoderCGI builders and parsers, the API style that we agreed upon seemed to encourage logic to be spread out and repeated.  As a brief recap, we were trying to avoid a single factory method or constructor with a long parameter list, because it's too easy for a client to get wrong, and calls to it aren't particularly readable.  Here's an example of that:

----

Person person = new Person( "John", "Jackson", 1979, 11, 10,
    "AC2193" );

----

  We wanted something more like:

----

Person person = new Person.Builder().forename( " John" )
    .surname( "Jackson" ).yearOfBirth( 1979 )
    .monthOfBirth( 11 ).dateOfBirth( 10 )
    .nationalInsuranceNumber( "AC2193" ).build();

----

  To keep the code short, we'll use a simpler class as an example, a Person consisting of name and age.

----

public class Person
{
    private final String name;
    private final int age;

    private Person( Builder builder )
    {
        this.builder = builder;
    }

    public static class Builder
    {
        private String name;
        private int age;

        public Builder name( String name )
        {
            this.name = name;
            return this;
        }

        public Builder age( int age )
        {
            this.age = age;
            return this;
        }

        public Person build()
        {
            return new Person( this );
        }
    }

    public String getName()
    {
        return name;
    }

    public int age()
    {
        return age;
    }
}

----

** MaxOnce

  Even for 2 parameters, this is quite a lot of code, though thus far there isn't really any logic to be duplicated.  Now let's look at a really simple constraint, that values cannot be set twice.

  The most obvious way of trying this would be to have a boolean alongside each field in the builder, e.g.:

----

private String name;
private boolean nameAlreadySet;

private int age;
private boolean ageAlreadySet;

----

  And then in the name( String ) and age( int ) methods in the Builder you would check the value of that boolean, and throw an IllegalStateException if the boolean had already been set.  This is clearly a repetition, which can lead to copy-and-paste errors or just make things hard to change.

  In object-orientated programming the usual way of handling this would be to package the field with its boolean in an object, which we decided to call MaxOnce.  Though it doesn't exist in the current version of the code, we had it in an early version and it's relevant in understanding the reasons for the current design.

----

class MaxOnce<T>
{
    private T value;
    private boolean alreadySet;
    private final String name;

    public MaxOnce( T defaultValue, String name )
    {
        value = defaultValue;
        this.name = name;
    }

    public void set( T newValue )
    {
        if ( alreadySet )
        {
            throw new IllegalStateException( "Cannot set " + name +
                " to " + newValue + "; it already has the value " +
                value );
        }

        value = newValue;
        alreadySet = true;
    }

    public T get()
    {
        return value;
    }
}

----

  So then the fields section in the Builder would look like this:

----

private final MaxOnce<String> name =
    new MaxOnce<String>( null, "name" );

private final MaxOnce<Integer> age =
    new MaxOnce<Integer>( 0, "age" );

----

  This is handy because it also moves the logic from the methods in the Builder class to one place, the MaxOnce class, solving the general goal of keeping logic unrepeated.

** BoundedInt and ParameterDescription

  It's easy to guess that the age of a Person should be restricted to values greater than 0 (which in turn makes the default value of 0 a bit useless, but we'll get around to that).  It's easy enough to add in such a constraint in the Builder's methods:

----

public Builder age( int age )
{
    if ( age <= 0 )
    {
        throw new IllegalArgumentException( age + " is not a " +
            "valid value for the age parameter" );
    }

    this.age = age;

    return this;
}

----

  If the above was followed for all the CGI queries, we would find it repeated in a number of places.  There is a slight urge to add bounds checking to MaxOnce, but if that was done then MaxOnce would no longer be a good name for it!

  One idea that fell by the wayside was a BoundedInt type, which had a 'set' method that would check bounds.  So you could have, in the Builder:

----

private final BoundedInt age = new BoundedInt( 0, 0,
    Integer.MAX_VALUE, "age" );

----

  This would work but it wouldn't compose well with MaxOnce.  If you wrote:

----

private final MaxOnce<BoundedInt> age = new MaxOnce<BoundedInt>(
    new BoundedInt( 0, 0, Integer.MAX_VALUE, "age"), "age" );

----

  then you would probably start to get annoyed!  Plus, it becomes difficult to make sure you call the set methods of both MaxOnce and BoundedInt properly.  It would help if MaxOnce and BoundedInt were more like filters that data gets passed through (or not, if the data is invalid).  Enter the ParameterDescription class, or rather, the first iteration of it:

----

private final ParameterDescription<String> name = maxOnce( "name", null );

private final ParameterDescription<Integer> age = bound( maxOnce( "age", 0 ),
    0, Integer.MAX_VALUE );

----

  Notice how bound and maxOnce are chained together in the age parameter.  It's easy to see how you might write other filters.  Here's a largely useless example:

----

ParameterDescription<Integer> number = 
    not ( 5,
    bound (
        maxOnce ( 0, "a number from one to ten, but not five" ),
        0, 10 ) );

----

  One more factor is needed to explain the differences between what has been described here thus far and the actual code; immutability.  Mutable state is a problem in software in general - a mutable object needs managing.  If Sun exposed the char[] inside java.lang.String I could make System.out.println( "Hello World"); actually print "Well, hello".  If you expose an internal List, array or StringBuilder that you depend on then you're likely to cause problems for yourself.  There are solutions, such as defensively cloning objects, but all these problems go away if you make objects immutable where possible.

  In the design as documented so far, each Parameter is mutable, as it holds a value that can change.  But really when we see the line where the Parameter is declared:

----

private final ParameterDescription<String, Option<String>> name =
    maxOnce( "name" );

----

  we can see that it is more a declaration of the parameter than it is an actual value.  We can make this immutable by moving the value elsewhere.  Roughly, we can move it to a Map\<ParameterDescription, Object\> but with slightly better types.  The types of this map are a little awkward to get right, as {{{http://code.google.com/p/google-guice/source/browse/trunk/src/com/google/inject/InjectorImpl.java?r=255}Bob Lee found while implementing Guice}} (search for 'unchecked'), so it's wise to wrap this map up, preventing incorrectly-typed access.  The wrapper in this project is called ParameterMap.

  By moving the values of all the parameters to ParameterMap, we can then make the whole thing immutable by making changes to the ParameterMap not actually change the instance but return a new instance.  Unfortunately, the implementations of Map that come with Java are certainly not optimised for this copy-on-write behaviour (unlike java.util.CopyOnWriteArrayList), but there are some fast immutable hashtable implementations out there ready for us to use if there turns out to be a performance problem.  Probably a better optimisation would be to stop using TreeMap anyway, as it isn't especially fast or compact for small datasets.

  So with ParameterMap involved, we don't even need the parameters to be instance fields any more.  Because a large part of the project is about parsing and building URLs, you'll notice that the parameters include conversions (TwoWayConversion) to convert between their values and Strings.